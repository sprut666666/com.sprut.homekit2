"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
class ExtendedBuffer {
    constructor(options = {}) {
        this._maxBufferLength = options.maxBufferLength || buffer_1.kMaxLength;
        this._initEmptyBuffer();
    }
    static get maxSize() {
        return buffer_1.kMaxLength;
    }
    static concat(list, totalLength) {
        let buffer = new this;
        let listLength = list.length;
        for (let i = 0; i < listLength; ++i) {
            buffer.writeBuffer(list[i], false);
            if (undefined !== totalLength && buffer.length >= totalLength) {
                buffer._pointerEnd = buffer._pointerStart + totalLength;
                break;
            }
        }
        return buffer;
    }
    static zigZagEncode32(value) {
        return (((value |= 0) << 1) ^ (value >> 31)) >>> 0;
    }
    static zigZagDecode32(value) {
        return ((value >>> 1) ^ -(value & 1)) | 0;
    }
    get length() {
        return this._pointerEnd - this._pointerStart;
    }
    get nativeLength() {
        return this._nativeBuffer.length;
    }
    get buffer() {
        return this._nativeBuffer.slice(this._pointerStart, this._pointerEnd);
    }
    _initEmptyBuffer() {
        this._pointerStart = this._pointerEnd = Math.floor(this._maxBufferLength / 2);
        this._nativeBuffer = buffer_1.Buffer.allocUnsafe ? buffer_1.Buffer.allocUnsafe(this._maxBufferLength) : new buffer_1.Buffer(this._maxBufferLength);
        this._pointer = 0;
        return this;
    }
    clean() {
        return this._initEmptyBuffer();
    }
    getFreeSpaceStart() {
        return this._pointerStart;
    }
    getFreeSpaceEnd() {
        return this._nativeBuffer.length - this._pointerEnd;
    }
    getFreeSpace() {
        return this.getFreeSpaceStart() + this.getFreeSpaceEnd();
    }
    allocStart(byteLength) {
        if (byteLength > this.getFreeSpaceStart()) {
            if (byteLength > this.getFreeSpace()) {
                throw new RangeError('Not enough free space');
            }
            const offset = Math.floor((this.getFreeSpace() - byteLength) / 2) + byteLength - this._pointerStart;
            this._nativeBuffer.copy(this._nativeBuffer, this._pointerStart + offset, this._pointerStart, this._pointerEnd);
            this._pointerStart += offset;
            this._pointerEnd += offset;
        }
        return this;
    }
    allocEnd(byteLength) {
        if (byteLength > this.getFreeSpaceEnd()) {
            if (byteLength > this.getFreeSpace()) {
                throw new RangeError('Not enough free space');
            }
            let offset = this._nativeBuffer.length - Math.floor((this.getFreeSpace() - byteLength) / 2) - byteLength - this._pointerEnd;
            this._nativeBuffer.copy(this._nativeBuffer, this._pointerStart + offset, this._pointerStart, this._pointerEnd);
            this._pointerStart += offset;
            this._pointerEnd += offset;
        }
        return this;
    }
    getReadableSize() {
        return this._pointerEnd - this._pointerStart - this._pointer;
    }
    getWritableSize() {
        return this.getFreeSpace();
    }
    _writeNativeBuffer(buffer, unshift) {
        if (unshift) {
            this.allocStart(buffer.length);
            this._pointerStart -= buffer.length;
            buffer.copy(this._nativeBuffer, this._pointerStart);
        }
        else {
            this.allocEnd(buffer.length);
            buffer.copy(this._nativeBuffer, this._pointerEnd);
            this._pointerEnd += buffer.length;
        }
        return this;
    }
    gc() {
        if (this._pointer > 0) {
            let payload = this._nativeBuffer.slice(this._pointerStart + this._pointer, this._pointerEnd);
            return this._initEmptyBuffer()._writeNativeBuffer(payload, false);
        }
        return this;
    }
    nodeGc() {
        global.gc && global.gc();
        return this;
    }
    setPointer(pointer) {
        if (pointer >= 0 && pointer <= this.length) {
            this._pointer = pointer;
        }
        else {
            this._pointer = pointer < 0 ? 0 : this.length;
        }
        return this;
    }
    getPointer() {
        return this._pointer;
    }
    offset(offset) {
        return this.setPointer(this._pointer + offset);
    }
    isReadable(byteLength = 1) {
        byteLength = byteLength < 1 ? 1 : byteLength;
        return this.getReadableSize() >= byteLength;
    }
    isWritable(byteLength = 1) {
        byteLength = byteLength < 1 ? 1 : byteLength;
        return this.getFreeSpace() >= byteLength;
    }
    toString(encoding, start, end) {
        return this.buffer.toString(encoding, start, end);
    }
    writeBuffer(value, unshift) {
        if (value instanceof buffer_1.Buffer) {
            return this._writeNativeBuffer(value, unshift);
        }
        else if (value instanceof ExtendedBuffer) {
            return this._writeNativeBuffer(value.buffer, unshift);
        }
        else {
            throw new TypeError('"value" is incorrect buffer');
        }
    }
    writeString(string, encoding, unshift) {
        let byteLength = buffer_1.Buffer.byteLength(string, encoding);
        if (unshift) {
            this.allocStart(byteLength);
            this._pointerStart -= byteLength;
            this._nativeBuffer.write(string, this._pointerStart, byteLength, encoding);
        }
        else {
            this.allocEnd(byteLength);
            this._nativeBuffer.write(string, this._pointerEnd, byteLength, encoding);
            this._pointerEnd += byteLength;
        }
        return this;
    }
    writeIntBE(value, byteLength, unshift, noAssert) {
        if (unshift) {
            this.allocStart(byteLength);
            this._pointerStart -= byteLength;
            this._nativeBuffer.writeIntBE(value, this._pointerStart, byteLength, noAssert);
        }
        else {
            this.allocEnd(byteLength);
            this._nativeBuffer.writeIntBE(value, this._pointerEnd, byteLength, noAssert);
            this._pointerEnd += byteLength;
        }
        return this;
    }
    writeIntLE(value, byteLength, unshift, noAssert) {
        if (unshift) {
            this.allocStart(byteLength);
            this._pointerStart -= byteLength;
            this._nativeBuffer.writeIntLE(value, this._pointerStart, byteLength, noAssert);
        }
        else {
            this.allocEnd(byteLength);
            this._nativeBuffer.writeIntLE(value, this._pointerEnd, byteLength, noAssert);
            this._pointerEnd += byteLength;
        }
        return this;
    }
    writeUIntBE(value, byteLength, unshift, noAssert) {
        if (unshift) {
            this.allocStart(byteLength);
            this._pointerStart -= byteLength;
            this._nativeBuffer.writeUIntBE(value, this._pointerStart, byteLength, noAssert);
        }
        else {
            this.allocEnd(byteLength);
            this._nativeBuffer.writeUIntBE(value, this._pointerEnd, byteLength, noAssert);
            this._pointerEnd += byteLength;
        }
        return this;
    }
    writeUIntLE(value, byteLength, unshift, noAssert) {
        if (unshift) {
            this.allocStart(byteLength);
            this._pointerStart -= byteLength;
            this._nativeBuffer.writeUIntLE(value, this._pointerStart, byteLength, noAssert);
        }
        else {
            this.allocEnd(byteLength);
            this._nativeBuffer.writeUIntLE(value, this._pointerEnd, byteLength, noAssert);
            this._pointerEnd += byteLength;
        }
        return this;
    }
    writeInt8(value, unshift, noAssert) {
        return this.writeIntBE(value, 1, unshift, noAssert);
    }
    writeUInt8(value, unshift, noAssert) {
        return this.writeUIntBE(value, 1, unshift, noAssert);
    }
    writeInt16BE(value, unshift, noAssert) {
        return this.writeIntBE(value, 2, unshift, noAssert);
    }
    writeInt16LE(value, unshift, noAssert) {
        return this.writeIntLE(value, 2, unshift, noAssert);
    }
    writeUInt16BE(value, unshift, noAssert) {
        return this.writeUIntBE(value, 2, unshift, noAssert);
    }
    writeUInt16LE(value, unshift, noAssert) {
        return this.writeUIntLE(value, 2, unshift, noAssert);
    }
    writeInt32BE(value, unshift, noAssert) {
        return this.writeIntBE(value, 4, unshift, noAssert);
    }
    writeInt32LE(value, unshift, noAssert) {
        return this.writeIntLE(value, 4, unshift, noAssert);
    }
    writeUInt32BE(value, unshift, noAssert) {
        return this.writeUIntBE(value, 4, unshift, noAssert);
    }
    writeUInt32LE(value, unshift, noAssert) {
        return this.writeUIntLE(value, 4, unshift, noAssert);
    }
    writeFloatBE(value, unshift, noAssert) {
        if (unshift) {
            this.allocStart(4);
            this._pointerStart -= 4;
            this._nativeBuffer.writeFloatBE(value, this._pointerStart, noAssert);
        }
        else {
            this.allocEnd(4);
            this._nativeBuffer.writeFloatBE(value, this._pointerEnd, noAssert);
            this._pointerEnd += 4;
        }
        return this;
    }
    writeFloatLE(value, unshift, noAssert) {
        if (unshift) {
            this.allocStart(4);
            this._pointerStart -= 4;
            this._nativeBuffer.writeFloatLE(value, this._pointerStart, noAssert);
        }
        else {
            this.allocEnd(4);
            this._nativeBuffer.writeFloatLE(value, this._pointerEnd, noAssert);
            this._pointerEnd += 4;
        }
        return this;
    }
    writeDoubleBE(value, unshift, noAssert) {
        if (unshift) {
            this.allocStart(8);
            this._pointerStart -= 8;
            this._nativeBuffer.writeDoubleBE(value, this._pointerStart, noAssert);
        }
        else {
            this.allocEnd(8);
            this._nativeBuffer.writeDoubleBE(value, this._pointerEnd, noAssert);
            this._pointerEnd += 8;
        }
        return this;
    }
    writeDoubleLE(value, unshift, noAssert) {
        if (unshift) {
            this.allocStart(8);
            this._pointerStart -= 8;
            this._nativeBuffer.writeDoubleLE(value, this._pointerStart, noAssert);
        }
        else {
            this.allocEnd(8);
            this._nativeBuffer.writeDoubleLE(value, this._pointerEnd, noAssert);
            this._pointerEnd += 8;
        }
        return this;
    }
    writeVarInt32(value, unshift) {
        value >>>= 0;
        let b;
        if (unshift) {
            let buffer = new ExtendedBuffer({
                maxBufferLength: 10
            });
            while (value >= 0x80) {
                b = (value & 0x7f) | 0x80;
                buffer.writeUIntBE(b, 1);
                value >>>= 7;
            }
            buffer.writeUIntBE(value, 1);
            return this._writeNativeBuffer(buffer.buffer, true);
        }
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.writeUIntBE(b, 1);
            value >>>= 7;
        }
        return this.writeUIntBE(value, 1);
    }
    readBuffer(size, asNative, bufferOptions) {
        let buffer = this._nativeBuffer.slice(this._pointerStart + this._pointer, this._pointerStart + this._pointer + size);
        this._pointer += size;
        const ThisClass = this.constructor;
        if (asNative) {
            return buffer_1.Buffer.from ? buffer_1.Buffer.from(buffer) : new buffer_1.Buffer(buffer);
        }
        return (new ThisClass(bufferOptions))._writeNativeBuffer(buffer, false);
    }
    readString(size, encoding) {
        this._pointer += size;
        return this._nativeBuffer.toString(encoding, this._pointerStart + this._pointer - size, this._pointerStart + this._pointer);
    }
    readIntBE(byteLength, noAssert) {
        this._pointer += byteLength;
        return this._nativeBuffer.readIntBE(this._pointerStart + this._pointer - byteLength, byteLength, noAssert);
    }
    readIntLE(byteLength, noAssert) {
        this._pointer += byteLength;
        return this._nativeBuffer.readIntLE(this._pointerStart + this._pointer - byteLength, byteLength, noAssert);
    }
    readUIntBE(byteLength, noAssert) {
        this._pointer += byteLength;
        return this._nativeBuffer.readUIntBE(this._pointerStart + this._pointer - byteLength, byteLength, noAssert);
    }
    readUIntLE(byteLength, noAssert) {
        this._pointer += byteLength;
        return this._nativeBuffer.readUIntLE(this._pointerStart + this._pointer - byteLength, byteLength, noAssert);
    }
    readInt8(noAssert) {
        return this.readIntBE(1, noAssert);
    }
    readUInt8(noAssert) {
        return this.readUIntBE(1, noAssert);
    }
    readInt16BE(noAssert) {
        return this.readIntBE(2, noAssert);
    }
    readInt16LE(noAssert) {
        return this.readIntLE(2, noAssert);
    }
    readUInt16BE(noAssert) {
        return this.readUIntBE(2, noAssert);
    }
    readUInt16LE(noAssert) {
        return this.readUIntLE(2, noAssert);
    }
    readInt32BE(noAssert) {
        return this.readIntBE(4, noAssert);
    }
    readInt32LE(noAssert) {
        return this.readIntLE(4, noAssert);
    }
    readUInt32BE(noAssert) {
        return this.readUIntBE(4, noAssert);
    }
    readUInt32LE(noAssert) {
        return this.readUIntLE(4, noAssert);
    }
    readFloatBE(noAssert) {
        this._pointer += 4;
        return this._nativeBuffer.readFloatBE(this._pointerStart + this._pointer - 4, noAssert);
    }
    readFloatLE(noAssert) {
        this._pointer += 4;
        return this._nativeBuffer.readFloatLE(this._pointerStart + this._pointer - 4, noAssert);
    }
    readDoubleBE(noAssert) {
        this._pointer += 8;
        return this._nativeBuffer.readDoubleBE(this._pointerStart + this._pointer - 8, noAssert);
    }
    readDoubleLE(noAssert) {
        this._pointer += 8;
        return this._nativeBuffer.readDoubleLE(this._pointerStart + this._pointer - 8, noAssert);
    }
    readVarInt32() {
        let c = 0;
        let value = 0 >>> 0;
        let b;
        do {
            b = this.readUIntBE(1);
            if (c < 5) {
                value |= (b & 0x7f) << (7 * c);
            }
            ++c;
        } while ((b & 0x80) !== 0);
        return value | 0;
    }
    isReadableVarInt32() {
        let c = 0;
        let value = 0 >>> 0;
        let b;
        let oldPointer = this._pointer;
        do {
            if (!this.isReadable(1)) {
                this._pointer = oldPointer;
                return false;
            }
            b = this.readUIntBE(1);
            if (c < 5) {
                value |= (b & 0x7f) << (7 * c);
            }
            ++c;
        } while ((b & 0x80) !== 0);
        this._pointer = oldPointer;
        return true;
    }
}
exports.ExtendedBuffer = ExtendedBuffer;
